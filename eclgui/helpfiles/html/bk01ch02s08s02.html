<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Fields in Datasets</title><link rel="stylesheet" href="eclipsehelp.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="ECL Reference"><link rel="up" href="bk01ch02s08.html" title="Field and Attribute Qualification"><link rel="prev" href="bk01ch02s08s01.html" title="Imported Attributes"><link rel="next" href="bk01ch02s08s03.html" title="Scope Resolution Operator"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Fields in Datasets</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="bk01ch02s08s01.html">Prev</a>&nbsp;</td><th width="60%" align="center">Field and Attribute Qualification</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="bk01ch02s08s03.html">Next</a></td></tr></table><hr></div><div class="sect2" title="Fields in Datasets"><div class="titlepage"><div><div><h3 class="title"><a name="Fields_in_Datasets"></a>Fields in Datasets</h3></div></div></div><p>Each Dataset counts as a qualified scope and the fields within them are fully qualified by their Dataset (or record set) name and Field name, using dot syntax (dataset.field). Similarly, the result set of the TABLE<a class="indexterm" name="d4e636"></a> built-in function (see the <span class="bold"><strong>TABLE</strong></span> keyword) also acts as a qualified scope. The name of the record set to which a field belongs is the object name:</p><pre class="programlisting">Young := YearOf(Person.per_dbrth) &lt; 1950;
MySet := Person(Young);</pre><p>When naming a Dataset as part of an Attribute definition, the fields of that Attribute (or record set) come into scope. If Parameterized Attributes (functions) are nested, only the innermost scope is available. That is, all the fields of a Dataset (or derived record set) are in scope in the filter expression. This is also true for expressions parameters of any built-in function that names a Dataset or derived record set as a parameter.</p><pre class="programlisting">MySet1 := Person(YearOf(dbrth) &lt; 1950);
// MySet1 is the set of Person records who were born before 1950</pre><p></p><pre class="programlisting">MySet2 := Person(EXISTS(OpenTrades(AgeOf(trd_dla) &lt; AgeOf(Person.per_dbrth))));</pre><p></p><pre class="programlisting">// OpenTrades is a pre-defined record set.
//All Trades fields are in scope in the OpenTrades record set filter 
//expression, but Person is required here to bring Person.per_dbrth
// into scope
//This example compares each trades' Date of Last Activity to the
// related person&#8217;s Date Of Birth</pre><p>Any field in a Record Set <span class="underline">can</span> be qualified with either the Dataset name the Record Set is based on, or any other Record Set name based on the same base dataset. For example:</p><pre class="programlisting">memtrade.trd_drpt
nondup_trades.trd_drpt
trades.trd_drpt</pre><p>all refer to the same field in the memtrade dataset.</p><p>For consistency, you should typically use the base dataset name for qualification. You can also use the current Record Set's name in any context where the base dataset name would be confusing.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bk01ch02s08s01.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="bk01ch02s08.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="bk01ch02s08s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Imported Attributes&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Scope Resolution Operator</td></tr></table></div></body></html>