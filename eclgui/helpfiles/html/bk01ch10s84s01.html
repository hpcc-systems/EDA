<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>PARSE Text Data</title><link rel="stylesheet" href="eclipsehelp.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="ECL Reference"><link rel="up" href="bk01ch10s84.html" title="PARSE"><link rel="prev" href="bk01ch10s84.html" title="PARSE"><link rel="next" href="bk01ch10s84s02.html" title="PARSE XML Data"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">PARSE Text Data</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="bk01ch10s84.html">Prev</a>&nbsp;</td><th width="60%" align="center">PARSE</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="bk01ch10s84s02.html">Next</a></td></tr></table><hr></div><div class="sect2" title="PARSE Text Data"><div class="titlepage"><div><div><h3 class="title"><a name="PARSE_Text_Data"></a>PARSE Text<a class="indexterm" name="d4e10698"></a> Data</h3></div></div></div><p>The first form operates on the <span class="emphasis"><em>dataset</em></span>, finding records whose <span class="emphasis"><em>data</em></span> contains a match for the <span class="emphasis"><em>pattern,</em></span> producing a result set of those matches in the <span class="emphasis"><em>result </em></span>format. If the <span class="emphasis"><em>pattern</em></span> finds multiple matches in the <span class="emphasis"><em>data</em></span>, then a result record is generated for each match. Each match for a PARSE is effectively a single path through the <span class="emphasis"><em>pattern</em></span>. If there is more than one path that matches, then the <span class="emphasis"><em>result</em></span> transform is either called once for each path, or if the BEST option is used, the path with the lowest penalty is selected.</p><p>If the <span class="emphasis"><em>result</em></span> names a RECORD structure, then this form of PARSE operates like the TABLE function to generate the result set, but may also operate on variable length text. If the <span class="emphasis"><em>result</em></span> names a TRANSFORM function, then the transform generates the result set. The TRANSFORM function must take at least one parameter: a LEFT record of the same format as the <span class="emphasis"><em>dataset</em></span>. The format of the resulting record set does not need to be the same as the input.</p><p><span class="emphasis"><em>Flags</em></span> can have the following values:</p><div class="informaltable"><table border="0"><colgroup><col width="17%"><col width="83%"></colgroup><tbody><tr><td><span class="bold"><strong>FIRST<a class="indexterm" name="d4e10724"></a></strong></span></td><td>Only return a row for the first match starting at a particular position.</td></tr><tr><td><span class="bold"><strong>ALL<a class="indexterm" name="d4e10730"></a></strong></span></td><td>Return a row for every possible match of the string at a particular position.</td></tr><tr><td><span class="bold"><strong>WHOLE<a class="indexterm" name="d4e10736"></a></strong></span></td><td>Only match the whole string.</td></tr><tr><td><span class="bold"><strong>NOSCAN<a class="indexterm" name="d4e10742"></a></strong></span></td><td>If a position matches, don't continue searching for other matches.</td></tr><tr><td><span class="bold"><strong>SCAN<a class="indexterm" name="d4e10748"></a></strong></span></td><td>If a position matches, continue searching from the end of the match, otherwise continue from the next position.</td></tr><tr><td><span class="bold"><strong>SCAN ALL<a class="indexterm" name="d4e10754"></a></strong></span></td><td>Return matches for every possible start position. Use the TRIM function to eliminate parsing extraneous trailing blanks.</td></tr><tr><td><span class="bold"><strong>NOCASE<a class="indexterm" name="d4e10760"></a></strong></span></td><td>Perform a case insensitive comparison.</td></tr><tr><td><span class="bold"><strong>CASE<a class="indexterm" name="d4e10766"></a></strong></span></td><td>Perform a case sensitive comparison (this is the default).</td></tr><tr><td><span class="bold"><strong>SKIP</strong></span><a class="indexterm" name="d4e10772"></a>(<span class="emphasis"><em>separator-pattern</em></span>)</td><td>Specify a pattern that can be inserted after each token in a search pattern. For example, SKIP ( [&#8216; &#8216;,'\t']*) skips spaces and tabs between tokens.</td></tr><tr><td><span class="bold"><strong>KEEP</strong></span><a class="indexterm" name="d4e10779"></a>(<span class="emphasis"><em>max</em></span>)</td><td>Only keep the first <span class="emphasis"><em>max</em></span> matches.</td></tr><tr><td><span class="bold"><strong>ATMOST</strong></span><a class="indexterm" name="d4e10787"></a>(<span class="emphasis"><em>max</em></span>)</td><td>Don't produce any matches if there are more than <span class="emphasis"><em>max</em></span> matches.</td></tr><tr><td><span class="bold"><strong>MAX<a class="indexterm" name="d4e10795"></a></strong></span></td><td>Return a row for the result that matches the longest sequence of the input. Only one match is returned unless the MANY option is also specified.</td></tr><tr><td><span class="bold"><strong>MIN<a class="indexterm" name="d4e10801"></a></strong></span></td><td>Return a row for the result that matches the shortest sequence of the input. Only one match is returned unless the MANY option is also specified.</td></tr><tr><td><span class="bold"><strong>MATCHED<a class="indexterm" name="d4e10807"></a></strong></span>( [ <span class="emphasis"><em>rule-reference</em></span> ] )</td><td>Used when <span class="emphasis"><em>rule-reference</em></span> is used in a user-matching function. If a rule-reference is not specified, the matching information may not be preserved.</td></tr><tr><td><span class="bold"><strong>MATCHED(ALL)<a class="indexterm" name="d4e10815"></a></strong></span></td><td>Retain all rule-names &#8211; if they are used by user match functions.</td></tr><tr><td><span class="bold"><strong>NOT MATCHED<a class="indexterm" name="d4e10821"></a></strong></span></td><td>Generate a row if there were no matches on the input row. All calls to the MATCHED() function return false inside the <span class="emphasis"><em>resultstructure</em></span>.</td></tr><tr><td><span class="bold"><strong>NOT MATCHED ONLY<a class="indexterm" name="d4e10828"></a></strong></span></td><td>Only generate a row if no matches were found.</td></tr><tr><td><span class="bold"><strong>BEST<a class="indexterm" name="d4e10834"></a></strong></span></td><td>Pick the match with the highest score (lowest penalty). If the MAX or MIN flags are also present, they are applied first. Only one match is returned unless the MANY option is also specified.</td></tr><tr><td><span class="bold"><strong>MANY<a class="indexterm" name="d4e10840"></a></strong></span></td><td>Return multiple matches for BEST, MAX, or MIN options.</td></tr><tr><td><span class="bold"><strong>PARSE<a class="indexterm" name="d4e10846"></a></strong></span></td><td>Implements Tomita parsing<a class="indexterm" name="d4e10849"></a> instead of regular expression parsing technology.</td></tr><tr><td><span class="bold"><strong>USE<a class="indexterm" name="d4e10854"></a></strong></span>([ <span class="emphasis"><em>struct</em></span>, ] x)</td><td>Specifies using a RULE pattern attribute defined further on in the code with the DEFINE(x) function, introducing a recursive grammar (the only recursion allowed in ECL). If the optional <span class="emphasis"><em>struct</em></span> RECORD structure<a class="indexterm" name="d4e10859"></a> is specified, USE specifies using a RULE pattern attribute defined further on in the code with the DEFINE(x) function that produces a row result in the <span class="emphasis"><em>struct</em></span> RECORD structure<a class="indexterm" name="d4e10862"></a> format (valid only with the PARSE option also present). USE is required on PARSE when any patterns cannot be found by walking the rules from the root down without following any USEs.</td></tr></tbody></table></div><p>Example:</p><pre class="programlisting">rec := {STRING10000 line};
datafile := DATASET([
    {'Ge 34:2 And when Shechem the son of Hamor the Hivite, prince of the country, saw her,'+
     ' he took her, and lay with her, and defiled her.'},
    {'Ge 36:10 These are the names of Esaus sons; Eliphaz the son of Adah the wife of Esau,'+
     ' Reuel the son of Bashemath the wife of Esau.'}],rec);
PATTERN ws1 := [' ','\t',','];
PATTERN ws := ws1 ws1?;
PATTERN patStart := FIRST | ws;
PATTERN patEnd := LAST | ws;
PATTERN article := ['A','The','Thou','a','the','thou'];

TOKEN patWord := PATTERN('[a-zA-Z]+');
TOKEN Name := PATTERN('[A-Z][a-zA-Z]+');

RULE Namet := name OPT(ws ['the','king of','prince of'] ws name);
PATTERN produced := OPT(article ws) ['begat','father of','mother of'];
PATTERN produced_by := OPT(article ws) ['son of','daughter of'];
PATTERN produces_with := OPT(article ws) ['wife of'];

RULE relationtype := ( produced | produced_by | produces_with);
RULE progeny := namet ws relationtype ws namet;

results := RECORD
  STRING60 Le := MATCHTEXT(Namet[1]);
  STRING60 Ri := MATCHTEXT(Namet[2]);
  STRING30 RelationPhrase := MatchText(relationtype);
END;
outfile1 := PARSE(datafile,line,progeny,results,SCAN ALL);
</pre></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bk01ch10s84.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="bk01ch10s84.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="bk01ch10s84s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">PARSE&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;PARSE XML Data</td></tr></table></div></body></html>