<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>ParsePattern Definitions</title><link rel="stylesheet" href="eclipsehelp.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="ECL Reference"><link rel="up" href="bk01ch07s02.html" title="PARSE Pattern Value Types"><link rel="prev" href="bk01ch07s02.html" title="PARSE Pattern Value Types"><link rel="next" href="bk01ch07s03.html" title="NLP RECORD and TRANSFORM Functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">ParsePattern Definitions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="bk01ch07s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">PARSE Pattern Value Types</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="bk01ch07s03.html">Next</a></td></tr></table><hr></div><div class="sect2" title="ParsePattern Definitions"><div class="titlepage"><div><div><h3 class="title"><a name="ParsePattern_Definitions"></a>ParsePattern Definitions</h3></div></div></div><p>A <span class="emphasis"><em>parsepattern </em></span>may contain any combination of the following elements:</p><div class="informaltable"><table border="0"><colgroup><col width="21%" align="left"><col width="79%"></colgroup><tbody><tr><td align="left"><span class="emphasis"><em>pattern-name</em></span></td><td>The name of any previously defined PATTERN attribute.</td></tr><tr><td align="left">(<span class="emphasis"><em>pattern</em></span>)</td><td>Parentheses may be used for grouping.</td></tr><tr><td align="left"><span class="emphasis"><em>pattern1 pattern2</em></span></td><td><span class="emphasis"><em>Pattern1</em></span> followed by <span class="emphasis"><em>pattern2</em></span>.</td></tr><tr><td align="left">'<span class="emphasis"><em>string</em></span>'</td><td>A fixed text <span class="emphasis"><em>string, </em></span>which may contain escaped octal string control characters (for example, CtrlZ is &#8216;\032&#8217;).</td></tr><tr><td align="left"><span class="bold"><strong>FIRST</strong></span></td><td>Matches the start of the string to search. This is similar to the regular expression ^ token, which is <span class="underline">not</span> supported.</td></tr><tr><td align="left"><span class="bold"><strong>LAST</strong></span></td><td>Matches the end of the string to search. This is similar to the regular expression $ token, which is <span class="underline">not</span> supported.</td></tr><tr><td align="left"><span class="bold"><strong>ANY</strong></span></td><td>Matches any character.</td></tr><tr><td align="left"><span class="bold"><strong>REPEAT</strong></span>(<span class="emphasis"><em>pattern</em></span>)</td><td>Repeat the <span class="emphasis"><em>pattern</em></span> any number of times. The regular expression syntax <span class="emphasis"><em>pattern</em></span>* is supported as a shorthand for REPEAT(<span class="emphasis"><em>pattern</em></span>).</td></tr><tr><td align="left"><span class="bold"><strong>REPEAT</strong></span>(<span class="emphasis"><em>pattern</em></span>,<span class="emphasis"><em> expression</em></span>)</td><td>Repeat the <span class="emphasis"><em>pattern expression</em></span> times. The regular expression syntax <span class="emphasis"><em>pattern</em></span>*&lt;count&gt; is supported as a shorthand for REPEAT(<span class="emphasis"><em>pattern</em></span>,<span class="emphasis"><em>expression</em></span>), but the regular expression bounded repeats syntax <span class="emphasis"><em>pattern</em></span>{<span class="emphasis"><em>expression</em></span>} is <span class="underline">not</span>.</td></tr><tr><td align="left"><span class="bold"><strong>REPEAT</strong></span>(<span class="emphasis"><em>pattern</em></span>,<span class="emphasis"><em> low</em></span>, ANY [,MIN])</td><td>Repeat the <span class="emphasis"><em>pattern</em></span> <span class="emphasis"><em>low</em></span> or more times (with the MIN option making it a minimal match). The regular expression syntax <span class="emphasis"><em>pattern</em></span>+ is supported as a shorthand for REPEAT(<span class="emphasis"><em>pattern</em></span>,<span class="emphasis"><em>low</em></span>,ANY), but the regular expression bounded repeats syntax <span class="emphasis"><em>pattern</em></span>{<span class="emphasis"><em>expression ,</em></span>} is <span class="underline">not</span>.</td></tr><tr><td align="left"><span class="bold"><strong>REPEAT</strong></span>(<span class="emphasis"><em>pattern</em></span>,<span class="emphasis"><em> low</em></span>,<span class="emphasis"><em> high</em></span>)</td><td>Repeat the <span class="emphasis"><em>pattern</em></span> from <span class="emphasis"><em>low </em></span>to <span class="emphasis"><em>high </em></span>times. The regular expression bounded repeats syntax <span class="emphasis"><em>pattern</em></span>{<span class="emphasis"><em>low</em></span>,<span class="emphasis"><em>high</em></span>} is <span class="underline">not</span> supported.</td></tr><tr><td align="left"><span class="bold"><strong>OPT</strong></span>(<span class="emphasis"><em>pattern</em></span>)</td><td>An optional <span class="emphasis"><em>pattern</em></span>. The regular expression syntax <span class="emphasis"><em>pattern</em></span>? is supported as a shorthand for OPT(<span class="emphasis"><em>pattern</em></span>).</td></tr><tr><td align="left"><span class="emphasis"><em>pattern1</em></span> <span class="bold"><strong>OR</strong></span> <span class="emphasis"><em>pattern2</em></span></td><td>Either <span class="emphasis"><em>pattern1</em></span> or <span class="emphasis"><em>pattern2</em></span>. The regular expression syntax <span class="emphasis"><em>pattern1</em></span> | <span class="emphasis"><em>pattern2</em></span> is supported as a shorthand for OR.</td></tr><tr><td align="left">[<span class="emphasis"><em>list-of-patterns</em></span>]</td><td>A comma-delimited list of alternative <span class="emphasis"><em>patterns</em></span>, useful for string sets. This is the same as OR.</td></tr><tr><td align="left"><span class="emphasis"><em>pattern1</em></span> <span class="bold"><strong>[NOT] IN</strong></span> <span class="emphasis"><em>pattern2</em></span></td><td>Does the text matched with <span class="emphasis"><em>pattern1</em></span> also match <span class="emphasis"><em>pattern2</em></span>? <span class="emphasis"><em>Pattern1</em></span> [NOT] = <span class="emphasis"><em>pattern2</em></span> and <span class="emphasis"><em>pattern1</em></span> != <span class="emphasis"><em>pattern2 </em></span>are the same as using IN, but may make more sense in some situations.</td></tr><tr><td align="left"><span class="emphasis"><em>pattern1</em></span> <span class="bold"><strong>[NOT] BEFORE</strong></span> <span class="emphasis"><em>pattern2</em></span></td><td>Check if the given <span class="emphasis"><em>pattern2</em></span> does [not] follow <span class="emphasis"><em>pattern1</em></span>. <span class="emphasis"><em>Pattern2</em></span> is not consumed from the input.</td></tr><tr><td align="left"><span class="emphasis"><em>pattern1</em></span> <span class="bold"><strong>[NOT] AFTER</strong></span> <span class="emphasis"><em>pattern2</em></span></td><td>Check if the given <span class="emphasis"><em>pattern2</em></span> does [not] precede <span class="emphasis"><em>pattern1</em></span>. <span class="emphasis"><em>Pattern2</em></span> does not consume any input. It must also be a fixed length.</td></tr><tr><td align="left"><span class="emphasis"><em>pattern</em></span> <span class="bold"><strong>LENGTH</strong></span>(<span class="emphasis"><em>range</em></span>)</td><td>Check whether the length of a <span class="emphasis"><em>pattern</em></span> is in the <span class="emphasis"><em>range</em></span>. <span class="emphasis"><em>Range </em></span>can have the form &lt;value&gt;,&lt;min&gt;..&lt;max&gt;,&lt;min&gt;.. or ..&lt;max&gt; So &#8220;digit*3 NOT BEFORE digit&#8221; could be represented as &#8220;digit* LENGTH(3).&#8221; This is more efficient, and digit* can be defined as a token. &#8220;digit* LENGTH(4..6)&#8221; matches 4,5 and 6 digit sequences.</td></tr><tr><td align="left"><span class="bold"><strong>VALIDATE</strong></span>(<span class="emphasis"><em>pattern</em></span>, <span class="emphasis"><em>isValidExpression</em></span>)</td><td>Evaluate <span class="emphasis"><em>isValidExpression </em></span>to check if the <span class="emphasis"><em>pattern</em></span> is valid or not. <span class="emphasis"><em>isValidExpression </em></span>should use MATCHTEXT or MATCHUNICODE to refer to the text that matched the <span class="emphasis"><em>pattern</em></span>. For example, VALIDATE(alpha*, MATCHTEXT[4]=&#8217;Q&#8217;) is equivalent to alpha* = ANY*3 &#8216;Q&#8217; ANY* or more usefully: VALIDATE(alpha*,isSurnameService(MATCHTEXT));</td></tr><tr><td align="left"><span class="bold"><strong>VALIDATE</strong></span>(<span class="emphasis"><em>pattern</em></span>, <span class="emphasis"><em>isValidAsciiExpression</em></span>, <span class="emphasis"><em>isValidUnicodeExpression</em></span>)</td><td>A two parameter variant. Use the first <span class="emphasis"><em>isValidAsciiExpression</em></span> if the string being searched is ASCII; use the second if it is Unicode.</td></tr><tr><td align="left"><span class="bold"><strong>NOCASE</strong></span>(<span class="emphasis"><em>pattern</em></span>)</td><td>Matches the <span class="emphasis"><em>pattern</em></span> case insensitively, overriding the CASE option on the PARSE function. This may be nested within a CASE pattern.</td></tr><tr><td align="left"><span class="bold"><strong>CASE</strong></span>(<span class="emphasis"><em>pattern</em></span>)</td><td>Matches the <span class="emphasis"><em>pattern</em></span> case sensitively, overriding the NOCASE option on the PARSE function. This may be nested within a NOCASE pattern.</td></tr><tr><td align="left"><span class="emphasis"><em>pattern</em></span> <span class="bold"><strong>PENALTY</strong></span>(<span class="emphasis"><em>cost</em></span>)</td><td>Associate a penalty <span class="emphasis"><em>cost</em></span> with this match of the <span class="emphasis"><em>pattern</em></span>. This can be used to recover from grammars with unknown words. This requires use of the BEST option on the PARSE operation.</td></tr><tr><td align="left"><span class="bold"><strong>TOKEN</strong></span>(<span class="emphasis"><em>pattern</em></span>)</td><td>Treat the <span class="emphasis"><em>pattern </em></span>as a token.</td></tr><tr><td align="left"><span class="bold"><strong>PATTERN</strong></span>('<span class="emphasis"><em>regular expression</em></span>')</td><td><pre class="programlisting">Define a pattern using a <span class="emphasis"><em>regular expression </em></span>built from the following 
supported syntax elements: 
 (x)                        Grouping (not used for matching) 
 x|y                        Alteratives x or y 
 xy                         Concatenation of x and y. 
 x* x*?                     Zero or more. Greedy and minimal versions. 
 x+ x+?                     One or more. Greedy and minimal versions. 
 x? x??                     Zero or one. Greedy and minimal versions. 
 x{m} x{m,} x{m,n}          Bounded repeats, also minimal versions 
 [0-9abcdef]                A set of characters (may use ^ for exclusion list) 
 (?=&#8230;) (?!...)             Look ahead assertion 
 (?&lt;=&#8230;) (?&lt;!...)           Look behind assertion</pre></td></tr><tr><td align="left">&nbsp;</td><td><pre class="programlisting">The following character class expressions are supported (inside sets): 
[:alnum:]     [:cntrl:]     [:lower:]     [:upper:]     [:space:] 
[:alpha:]     [:digit:]     [:print:]     [:blank:]     [:graph:] 
[:punct:]     [:xdigit:]</pre></td></tr><tr><td align="left">&nbsp;</td><td><pre class="programlisting"><span class="emphasis"><em>Regular expressions</em></span> do <span class="underline">not</span> support:
    ^ $ to mark the beginning/end of the string 
    Collating symbols      [.ch.] 
    Equivalence<a class="indexterm" name="d4e3560"></a> class      [=e=]</pre></td></tr><tr><td align="left"><span class="bold"><strong>USE</strong></span>(<span class="emphasis"><em> </em></span><span class="bold"><strong>[</strong></span><span class="emphasis"><em> recstruct , </em></span><span class="bold"><strong>] </strong></span>'<span class="emphasis"><em>symbolname</em></span>' )</td><td>Specifies using a pattern defined later with the DEFINE(<span class="bold"><strong> </strong></span>'<span class="emphasis"><em>symbolname</em></span>') function. This creates a forward reference<a class="indexterm" name="d4e3573"></a>, practical only on RULE patterns for tomita parsing (the PARSE option is present on the PARSE function).</td></tr><tr><td align="left"><span class="bold"><strong>SELF </strong></span></td><td>References the pattern being defined (recursive). This is practical only in RULE patterns for tomita parsing (the PARSE option is present on the PARSE function).</td></tr></tbody></table></div><p>Examples:</p><pre class="programlisting">rs := RECORD
STRING100 line;
END;
ds := DATASET([{'the fox; and the hen'}], rs);


PATTERN ws := PATTERN('[ \t\r\n]');
PATTERN Alpha := PATTERN('[A-Za-z]');
PATTERN Word := Alpha+;
PATTERN Article := ['the', 'A'];
PATTERN JustAWord := Word PENALTY(1);
PATTERN notHen := VALIDATE(Word, MATCHTEXT != 'hen');
PATTERN NoHenWord := notHen PENALTY(1);
RULE NounPhraseComponent1 := JustAWord | Article ws Word;
RULE NounPhraseComponent2 := NoHenWord | Article ws Word;
ps1 := RECORD
          out1 := MATCHTEXT(NounPhraseComponent1);
END;

ps2 := RECORD
          out2 := MATCHTEXT(NounPhraseComponent2);
END;

p1 := PARSE(ds, line, NounPhraseComponent1, ps1, BEST, MANY, NOCASE);
p2 := PARSE(ds, line, NounPhraseComponent2, ps2, BEST, MANY, NOCASE);
OUTPUT(p1);
OUTPUT(p2);</pre><p>See Also: <a class="link" href="bk01ch10s84.html" title="PARSE">PARSE</a>, <a class="link" href="bk01ch05s01.html" title="RECORD Structure">RECORD Structure</a>, <a class="link" href="bk01ch09s07.html" title="TRANSFORM Structure">TRANSFORM Structure</a>, <a class="link" href="bk01ch05s02.html" title="DATASET">DATASET</a></p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bk01ch07s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="bk01ch07s02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="bk01ch07s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">PARSE Pattern Value Types&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;NLP RECORD and TRANSFORM Functions</td></tr></table></div></body></html>