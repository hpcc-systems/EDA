<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Available options</title><link rel="stylesheet" href="eclipsehelp.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"><link rel="home" href="index.html" title="ECL Reference"><link rel="up" href="bk01ch12s17.html" title="#OPTION"><link rel="prev" href="bk01ch12s17s01.html" title="Definition of Terms"><link rel="next" href="bk01ch12s18.html" title="#SET"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Available options</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="bk01ch12s17s01.html">Prev</a>&nbsp;</td><th width="60%" align="center">#OPTION</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="bk01ch12s18.html">Next</a></td></tr></table><hr></div><div class="sect2" title="Available options"><div class="titlepage"><div><div><h3 class="title"><a name="Available_options"></a>Available options</h3></div></div></div><p><span class="bold"><strong>The following options are generally useful: </strong></span></p><div class="informaltable"><table border="0"><colgroup><col width="30%"><col width="12%"><col width="58%"></colgroup><tbody><tr><td><span class="emphasis"><em>maxRunTime</em></span></td><td>Default: none</td><td>Sets the maximum number of seconds a job runs before it times out</td></tr><tr><td><span class="emphasis"><em>freezePersists</em></span></td><td>Default: false</td><td>If true, does not calculate/recalculate PERSISTed</td></tr><tr><td><span class="emphasis"><em>check&nbsp;</em></span></td><td>Default: true</td><td>If true, check for potential overflows of records.</td></tr><tr><td><span class="emphasis"><em>expandRepeatAnyAsDfa</em></span></td><td>Default: true</td><td>If true, expand ANY* in a DFA.</td></tr><tr><td><span class="emphasis"><em>forceFakeThor</em></span></td><td>Default: false</td><td>If true, force code to use hthor.</td></tr><tr><td><span class="emphasis"><em>forceGenerate</em></span></td><td>Default: false</td><td>If true, force .SO to be generated even if it's not worth it</td></tr><tr><td><span class="emphasis"><em>globalFold</em></span></td><td>Default: true</td><td>If true, perform a global constant fold before generating.</td></tr><tr><td><span class="emphasis"><em>globalOptimize</em></span></td><td>Default: false</td><td>If true, perform a global optimize.</td></tr><tr><td><span class="emphasis"><em>groupAllDistribute</em></span></td><td>Default: false</td><td>If true, GROUP,ALL generates a DISTRIBUTE instead of a global SORT.</td></tr><tr><td><span class="emphasis"><em>maximizeLexer</em></span></td><td>Default: false</td><td>If true, maximize the amount of work done in the lexer.</td></tr><tr><td><span class="emphasis"><em>maxLength</em></span></td><td>Default: 4096</td><td>Specify maximum length of a record.</td></tr><tr><td><span class="emphasis"><em>minimizeSpillSize</em></span></td><td>Default: false</td><td>If true, if a spill is filtered/deduped etc when read, reduce spill file size by splitting, filtering and then writing.</td></tr><tr><td><span class="emphasis"><em>optimizeGraph</em></span></td><td>Default: true</td><td>If true, optimize expressions in a graph before generation</td></tr><tr><td><span class="emphasis"><em>orderDiskFunnel</em></span></td><td>Default: true</td><td>If true, if all inputs to a funnel are disk reads, pull in</td></tr><tr><td><span class="emphasis"><em>parseDfaComplexity</em></span></td><td>Default: 2000</td><td>Maximum complexity of expression to convert to a DFA.</td></tr><tr><td><span class="emphasis"><em>pickBestEngine</em></span></td><td>Default: true</td><td>If true, use hthor if it is more efficient than Thor</td></tr><tr><td><span class="emphasis"><em>targetClusterType</em></span></td><td>hthor|Thor|roxie</td><td>What supercomputer type are we generating code for?</td></tr><tr><td><span class="emphasis"><em>topnLimit</em></span></td><td>Default: 10000</td><td>Maximum number of records to do topN on.</td></tr><tr><td><span class="emphasis"><em>outputLimit</em></span></td><td>Default: 10</td><td>Sets maximum size (in Mb) of result stored in workunit.</td></tr><tr><td><span class="emphasis"><em>sortIndexPayload</em></span></td><td>Default: true</td><td>Specifies sorting (or not) payload fields during a</td></tr><tr><td><span class="emphasis"><em>workflow</em></span></td><td>Default: true</td><td>Specifies enabling/disabling workflow services.</td></tr><tr><td><span class="emphasis"><em>foldStored</em></span></td><td>Default: false</td><td>Specifies all the stored variables are replaced with their default values, or values overridden by #stored. This can significantly reduce the size of the graph generated.</td></tr><tr><td><span class="emphasis"><em>skipFileFormatCrcCheck</em></span></td><td>Default: false</td><td>Specifies the CRC check on indexes is produces a warning and not an error.</td></tr><tr><td><span class="emphasis"><em>allowedClusters</em></span></td><td>Default: none</td><td>Specifies the comma-delimited list of cluster names (as a string constant) where the workunit may execute. This allows the job to be switched between clusters, manually or automatically, if the workunit is blocked on its assigned cluster and another valid cluster is available for use.</td></tr><tr><td><span class="emphasis"><em>AllowAutoSwitchQueue</em></span></td><td>Default: false</td><td>If true, specifies the workunit is automatically re-assigned to execute on another available cluster listed in allowedClusters when blocked on its assigned cluster.</td></tr><tr><td><span class="emphasis"><em>performWorkflowCse</em></span></td><td>Default: false</td><td>If true, specifies the code generator automatically detects opportunities for Common Sub-expression Elimination that may be "buried" within multiple PERSISTed attributes. If false, notification of these opportunities are displayed to the programmer as suggestions for the use of the INDEPENDENT Workflow Service.</td></tr></tbody></table></div><p><span class="bold"><strong>The following options are all about generating Logical graphs in a workunit. </strong></span></p><p>Logical graphs<a class="indexterm" name="d4e14960"></a> are stored in the workunit and viewed in ECL Watch. They include information about which attribute/line number/column the symbols are defined in. Exported attributes are represented by &lt;module&gt;.&lt;attribute&gt; in the header of the activity. Non-exported (local) attributes are represented as &lt;module&gt;.&lt;exported-attribute&gt;::&lt;non-exported-name&gt;</p><div class="informaltable"><table border="0"><colgroup><col width="30%"><col width="12%"><col width="58%"></colgroup><tbody><tr><td><span class="emphasis"><em>generateLogicalGraph</em></span></td><td>Default: false</td><td>If true, generates a Logical graph in addition to all the workunit graphs.</td></tr><tr><td><span class="emphasis"><em>generateLogicalGraphOnly</em></span></td><td>Default: false</td><td>If true, generates only the Logical graph for the workunit.</td></tr><tr><td><span class="emphasis"><em>logicalGraphExpandPersist</em></span></td><td>Default: true</td><td>If true, generates expands PERSISTed attributes.</td></tr><tr><td><span class="emphasis"><em>logicalGraphExpandStored</em></span></td><td>Default: false</td><td>If true, generates expands STORED attributes.</td></tr><tr><td><span class="emphasis"><em>logicalGraphIncludeName</em></span></td><td>Default: true</td><td>If true, generates attribute names in the header of the activity boxes.</td></tr><tr><td><span class="emphasis"><em>logicalGraphIncludeModule</em></span></td><td>Default: true</td><td>If true, generates module.attribute names in the header of the activity boxes.</td></tr><tr><td><span class="emphasis"><em>logicalGraphDisplayJavadoc</em></span></td><td>Default: true</td><td>If true, generates the Javadoc-style comments embedded in the ECL in place of the standard text that would be generated (see http://java.sun.com/j2se/javadoc/writingdoccomments/). Javadoc-style comments on RECORD structures or scalar attributes will not generate, as they have no graph Activity box directly associated.</td></tr><tr><td><span class="emphasis"><em>logicalGraphDisplayJavadocParameters</em></span></td><td>Default: false</td><td>If true, generates information about parameters in any Javadoc-style comments.</td></tr><tr><td><span class="emphasis"><em>filteredReadSpillThreshold</em></span></td><td>Default: 2</td><td>Filtered disk reads are spilled if will be duplicated more than N times.</td></tr><tr><td><span class="emphasis"><em>foldConstantCast</em></span></td><td>Default: true</td><td>If true, (cast)value is folded at generate time.</td></tr><tr><td><span class="emphasis"><em>foldFilter</em></span></td><td>Default: true</td><td>If true, filters are constant folded.</td></tr><tr><td><span class="emphasis"><em>foldAssign</em></span></td><td>Default: true</td><td>If true, TRANSFORMs are constant folded.</td></tr><tr><td><span class="emphasis"><em>foldSQL</em></span></td><td>Default: true</td><td>If true, SQL is constant folded.</td></tr><tr><td><span class="emphasis"><em>optimizeDiskRead</em></span></td><td>Default: true</td><td>If true, include project and filter in the transform for a disk read.</td></tr><tr><td><span class="emphasis"><em>optimizeSQL</em></span></td><td>Default: false</td><td>If true, optimize SQL.</td></tr><tr><td><span class="emphasis"><em>optimizeThorCounts</em></span></td><td>Default: true</td><td>If true, convert COUNT(diskfile) into optimized version.</td></tr><tr><td><span class="emphasis"><em>peephole</em></span></td><td>Default: true</td><td>If true, peephole optimize memcpy/memsets, etc.</td></tr><tr><td><span class="emphasis"><em>spotCSE</em></span></td><td>Default: true</td><td>If true, look for common sub-expressions in TRANSFORMs/filters.</td></tr></tbody></table><table border="0"><colgroup><col width="441"></colgroup><tbody><tr><td><span class="emphasis"><em></em></span></td></tr></tbody></table><table border="0"><colgroup><col width="30%"><col width="12%"><col width="58%"></colgroup><tbody><tr><td><span class="emphasis"><em>spotTopN</em></span></td><td>Default: true</td><td>If true, convert CHOOSEN(SORT()) into a topN activity.</td></tr><tr><td><span class="emphasis"><em>spotLocalMerge</em></span></td><td>Default: false</td><td>If true, if local JOIN and both sides are sorted, generate a light-weight merge.</td></tr><tr><td><span class="emphasis"><em>countIndex</em></span></td><td>Default: false</td><td>If true, optimize COUNT(index) into optimized version (also requires optimizeThorCounts).</td></tr><tr><td><span class="emphasis"><em>allowThroughSpill</em></span></td><td>Default: true</td><td>If true, allow through spills.</td></tr><tr><td><span class="emphasis"><em>optimizeBoolReturn</em></span></td><td>Default: true</td><td>If true, improve code when returning BOOLEAN from a function.</td></tr><tr><td><span class="emphasis"><em>optimizeSubString</em></span></td><td>Default: true</td><td>If true, don't allocate memory when doing a substring.</td></tr><tr><td><span class="emphasis"><em>thorKeys</em></span></td><td>Default: true</td><td>If true, allow INDEX operations in Thor.</td></tr><tr><td><span class="emphasis"><em>regexVersion</em></span></td><td>Default: 0</td><td>If set to 1, specifies use of the previous regular expression implementation, which may be faster but also may exceed stack limits.</td></tr><tr><td><span class="emphasis"><em>compileOptions</em></span></td><td>Default: none</td><td>Specify override compiler options (such as /Zm1000 to double the compiler heap size to workaround a heap overflow error).</td></tr><tr><td><span class="emphasis"><em>linkOptions</em></span></td><td>Default: none</td><td>Specify override linker options.</td></tr><tr><td><span class="emphasis"><em>optimizeProjects</em></span></td><td>Default: true</td><td>If false, disables automatic field projection/distribution optimization.</td></tr><tr><td><span class="emphasis"><em>notifyOptimizedProjects</em></span></td><td>Default: 0</td><td>If set to 1, reports optimizations to named attributes. If set to 2, reports all optimizations.</td></tr><tr><td><span class="emphasis"><em>optimizeProjectsPreservePersists</em></span></td><td>Default: false</td><td>If true, disables automatic field projection/distribution optimization around reading PERSISTed files. If a PERSISTed file is read on a different size cluster than it was created on, optimizing the projected fields can mean that the distribution/sort order cannot be recreated.</td></tr><tr><td><span class="emphasis"><em>aggressiveOptimizeProjects</em></span></td><td>Default: false</td><td>If true, enables attempted minimization of network traffic for sorts/distributes. This option doesn't usually result in significant benefits, but may do so in some specific cases.</td></tr><tr><td><span class="emphasis"><em>percolateConstants</em></span></td><td>Default: true</td><td>If false, disables attempted aggressive constant value optimizations.</td></tr></tbody></table></div><p><span class="bold"><strong>The following </strong></span><span class="bold"><strong>options</strong></span><span class="bold"><strong> are useful for debugging: </strong></span></p><div class="informaltable"><table border="0"><colgroup><col width="30%"><col width="12%"><col width="58%"></colgroup><tbody><tr><td><span class="emphasis"><em>clusterSize</em></span></td><td>Default: none</td><td>Override the number of nodes in the cluster (for testing)</td></tr><tr><td><span class="emphasis"><em>debugNlp</em></span></td><td>Default: false</td><td>If true, output debug information about the NLP processing to the .cpp file.</td></tr><tr><td><span class="emphasis"><em>resourceMaxMemory</em></span></td><td>Default: 400M</td><td>Maximum amount of memory a subgraph can use.</td></tr><tr><td><span class="emphasis"><em>resourceMaxSockets</em></span></td><td>Default: 2000</td><td>Maximum number of sockets a subgraph can use.</td></tr><tr><td><span class="emphasis"><em>resourceMaxActivities</em></span></td><td>Default: 200</td><td>Maximum number of activities a subgraph can contain.</td></tr><tr><td><span class="emphasis"><em>unlimitedResources</em></span></td><td>Default: false</td><td>If true, assume lots of resources when resourcing the graphs.</td></tr><tr><td><span class="emphasis"><em>traceRowXML</em></span></td><td>Default: false</td><td>If true, turns on tracing in ECL Watch graphs. This should only be used with small datasets for debugging purposes.</td></tr><tr><td><span class="emphasis"><em>_Probe</em></span></td><td>Default: false</td><td>If true, display all result rows from intermediate result sets in the graph in ECL Watch when used in conjunction with the traceRowXML option. This should only be used with small datasets for debugging purposes.</td></tr><tr><td><span class="emphasis"><em>debugQuery</em></span></td><td>Default: false</td><td>If true, compile query using debug settings.</td></tr><tr><td><span class="emphasis"><em>optimizeLevel</em></span></td><td>Default: 3 for roxie, else -1</td><td>Set the optimization level (optimizing compiler can be a lot slower...).</td></tr><tr><td><span class="emphasis"><em>checkAsserts</em></span></td><td>Default: true</td><td>If true, enables ASSERT checking.</td></tr></tbody></table></div><p><span class="bold"><strong>The following </strong></span><span class="bold"><strong>options</strong></span><span class="bold"><strong> are for advanced code generation use:</strong></span></p><p>These <span class="emphasis"><em>options</em></span> should be left alone unless you REALLY know what you are doing. Typically they are used internally by our developers to enable/disable features that are still in development. Occasionally the technical support staff will suggest that you change one of these settings to work around a problem that you encounter, but otherwise the default settings are recommended in all cases.</p><div class="informaltable"><table border="0"><colgroup><col width="30%"><col width="12%"><col width="58%"></colgroup><tbody><tr><td><span class="emphasis"><em>filteredReadSpillThreshold</em></span></td><td>Default: 2</td><td>Filtered disk reads are spilled if will be duplicated more than N times.</td></tr><tr><td><span class="emphasis"><em>foldConstantCast </em></span></td><td>Default: true</td><td>If true, (cast)value is folded at generate time.</td></tr><tr><td><span class="emphasis"><em>foldFilter </em></span></td><td>Default: true</td><td>If true, filters are constant folded.</td></tr><tr><td><span class="emphasis"><em>foldAssign </em></span></td><td>Default: true</td><td>If true, TRANSFORMs are constant folded.</td></tr><tr><td><span class="emphasis"><em>foldSQL </em></span></td><td>Default: true</td><td>If true, SQL is constant folded.</td></tr><tr><td><span class="emphasis"><em>optimizeDiskRead </em></span></td><td>Default: true</td><td>If true, include project and filter in the transform for a disk read.</td></tr><tr><td><span class="emphasis"><em>optimizeSQL </em></span></td><td>Default: false</td><td>If true, optimize SQL.</td></tr><tr><td><span class="emphasis"><em>optimizeThorCounts </em></span></td><td>Default: true</td><td>If true, convert COUNT(diskfile) into optimized version.</td></tr><tr><td><span class="emphasis"><em>peephole </em></span></td><td>Default: true</td><td>If true, peephole optimize memcpy/memsets, etc.</td></tr><tr><td><span class="emphasis"><em>spotCSE </em></span></td><td>Default: true</td><td>If true, look for common sub-expressions in TRANSFORMs/filters.</td></tr><tr><td><span class="emphasis"><em>spotTopN </em></span></td><td>Default: true</td><td>If true, convert CHOOSEN(SORT()) into a topN activity.</td></tr><tr><td><span class="emphasis"><em>spotLocalMerge </em></span></td><td>Default: false</td><td>If true, if local JOIN and both sides are sorted, generate a light-weight merge.</td></tr><tr><td><span class="emphasis"><em>countIndex </em></span></td><td>Default: false</td><td>If true, optimize COUNT(index) into optimized version (also requires optimizeThorCounts).</td></tr><tr><td><span class="emphasis"><em>allowThroughSpill </em></span></td><td>Default: true</td><td>If true, allow through spills.</td></tr><tr><td><span class="emphasis"><em>optimizeBoolReturn </em></span></td><td>Default: true</td><td>If true, improve code when returning BOOLEAN from a function.</td></tr><tr><td><span class="emphasis"><em>optimizeSubString </em></span></td><td>Default: true</td><td>If true, don't allocate memory when doing a substring.</td></tr><tr><td><span class="emphasis"><em>thorKeys </em></span></td><td>Default: true</td><td>If true, allow INDEX operations in thor.</td></tr><tr><td><span class="emphasis"><em>regexVersion </em></span></td><td>Default: 0</td><td>If set to 1, specifies use of the previous regular expression implementation, which may be faster but also may exceed stack limits.</td></tr><tr><td><span class="emphasis"><em>compileOptions </em></span></td><td>Default: none</td><td>Specify override compiler options (such as /Zm1000 to double the compiler heap size to workaround a heap overflow error).</td></tr><tr><td><span class="emphasis"><em>linkOptions </em></span></td><td>Default: none</td><td>Specify override linker options.</td></tr><tr><td><span class="emphasis"><em>optimizeProjects </em></span></td><td>Default: true</td><td>If false, disables automatic field projection/distribution optimization.</td></tr><tr><td><span class="emphasis"><em>notifyOptimizedProjects </em></span></td><td>Default: 0</td><td>If set to 1, reports optimizations to named attributes. If set to 2, reports all optimizations.</td></tr><tr><td><span class="emphasis"><em>optimizeProjectsPreservePersists </em></span></td><td>Default: false</td><td>If true, disables automatic field projection/distribution optimization around reading PERSISTed files. If a PERSISTed file is read on a different size cluster than it was created on, optimizing the projected fields can mean that the distribution/sort order cannot be recreated.</td></tr><tr><td><span class="emphasis"><em>aggressiveOptimizeProjects </em></span></td><td>Default: false</td><td>If true, enables attempted minimization of network traffic for sorts/distributes. This option doesn't usually result in significant benefits, but may do so in some specific cases.</td></tr><tr><td><span class="emphasis"><em>percolateConstants </em></span></td><td>Default: true</td><td>If false, disables attempted aggressive constant value optimizations.</td></tr></tbody></table></div><p>Example:</p><pre class="programlisting">  #OPTION('traceRowXml', TRUE);
  #OPTION('_Probe', TRUE);
  
  my_rec := RECORD
    STRING20 lname;
    STRING20 fname;
    STRING2 age;
  END;
  
  d := DATASET([{ 'PORTLY', 'STUART' , '39'},
              { 'PORTLY', 'STACIE' , '36'},
              { 'PORTLY', 'DARA' , ' 1'},
              { 'PORTLY', 'GARRETT', ' 4'}], my_rec);
  
  OUTPUT(d(d.age &gt; ' 1'), {lname, fname, age} );
  
  //************************************
  //This example demonstrates Logical Graphs and
  // Javadoc-style comment blocks
  #OPTION('generateLogicalGraphOnly',TRUE);
  #OPTION('logicalGraphDisplayJavadocParameters',TRUE);
  
  /**
  * Defines a record that contains information about a person
  */
  namesRecord :=
       RECORD
  string20    surname;
  string10    forename;
  integer2    age := 25;
       END;
  
  /**
  Defines a table that can be used to read the information from the file
  and then do something with it.
  */
  namesTable := DATASET('x',namesRecord,FLAT);
  
  
  /**
       Allows the name table to be filtered.
  
       @param ages The ages that are allowed to be processed.
            badForename Forname to avoid.
  
       @return the filtered dataset.
  */
  namesTable filtered(SET OF INTEGER2 ages, STRING badForename) :=
       namesTable(age in ages, forename != badForename);
  
  OUTPUT(filtered([10,20,33], ''));
</pre></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bk01ch12s17s01.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="bk01ch12s17.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="bk01ch12s18.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Definition of Terms&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;#SET</td></tr></table></div></body></html>